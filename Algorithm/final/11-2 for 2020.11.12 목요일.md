[CSE3081(2ë°˜)] ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ì™€ ë¶„ì„

2020í•™ë…„ë„ 2í•™ê¸° ê°•ì˜ìë£Œ

(2020.11.12 ëª©ìš”ì¼)

#### The Greedy Method

- A technique to follow the problem-solving heuristic of making the locally optimal choice at each stage.
- Strategy
  - Make the choice that appears best at each moment!
  - It is hoped to arrive at a globally optimal solution by making a locally optimal choice.
- Pros and cons
  - [ref](https://en.wikipedia.org/wiki/Greedy_algorithm)
  - Simple and straightforward to design an algorithm.
  - Does not guarantee the optimal solution to all problems 
    - Local maximum versus global maximum

#### Maximum Non-overlapping Intervals

- Problem
- Example

- Possible strategies for choosing activities 
  - Longest one first
  - Shortest one first
  - Earliest start first
  - Earliest finish first

- Correctness of â€œEarliest-finish-firstâ€-based algorithm
  - ê·€ë¥˜ë²• (Proof by contradiction)
  - Selecting *a*1 reduces the problem to finding an optimal solution for activities not overlapping with *a*1.

- Greedy algorithm

  â†’ $$O(n log n + n) = O(n log n)$$ time

#### Scheduling: Minimizing Total Time in the System 

- Problem
  - Consider a system in which a server is about to serve n clients. Let *T* = {*t*1, *t*2, ..., *t**n*} be a set of positive numbers, where **t****i** is the estimated time-to-completion for the *i*th client. What is the optimal order of service where the total (wait+service) time in the system is minimized?
  - Hair stylist with waiting clients, pending operations on a shared hard disk, etc.
- Example
  - *T* = {*t*1, *t*2, *t**3*} = {5, 10, 4}

| Schedule  | Total Time in the System          |
| --------- | --------------------------------- |
| [1, 2, 3] | 5 + (5 + 10) + (5 + 10 + 4) = 39  |
| [1, 3, 2] | 33                                |
| [2, 1, 3] | 10 + (10 + 5) + (10 + 5 + 4) = 44 |
| [2, 3, 1] | 43                                |
| [3, 1, 2] | â˜ 4 + (4 + 5) + (4 + 5 + 10) = 32 |
| [3, 2, 1] | 37                                |

- A naiÌˆve approach

  - Enumerate all possible schedules of service, and select the optimal one.

    â†’ *O*(*n*!)

- A greedy approach

  - Algorithm: Sort *T* in nondecreasing order to get the optimal schedule. â†’ *O*(*n* log *n*)
  - Correctness: Does the greedy approach always find a schedule that minimizes the total time in the system?
    - ê·€ë¥˜ë²• (Proof by contradiction)
    - Let *S* = [*s*1, *s*2, ..., *s**n*] be an optimal schedule, and *C*(*S*) be the total time for *S*. 
    - If they are not scheduled in nondecreasing order, then, for at least one *i*(1â‰¤*i*â‰¤*n*-1),*s**i* >*s**i*+1.
    - Now consider the schedule *Sâ€™* = [*s*1, *s*2, ..., *s**i*+1, *s**i*, ..., *s**n*] that is obtained by interchanging *s**i* and *s**i*+1.
    - Then,ğ¶ğ‘† âˆ’ğ¶ğ‘†â€² =(ğ‘–âˆ™ğ‘ ğ‘–+1+(ğ‘–+1)âˆ™ğ‘ ğ‘–)âˆ’(ğ‘–âˆ™ğ‘ ğ‘–+(ğ‘–+1)âˆ™ğ‘ ğ‘–+1)=ğ‘ ğ‘–âˆ’ ğ‘ ğ‘–+1 > 0. Therefore, ...

#### Scheduling: Minimizing Lateness

- Problem

  - Let *J* = {1, 2, ..., *n*} be a set of jobs to be served by a single processor.

  -  The *i*th job takes **t****i** units of processing time, and is due at time **d****i** .

  - When the *i*th job starts at time *s**i*, its lateness *l**i* = max{0, *s**i* + *t**i* - *d**i* }.

  - Goal: Find a schedule *S* so as to minimize the maximum lateness

    *L* = max{*l**i*}. 

- Example
  - *S* = {3, 2, 6, 1, 5, 4} â†’ maximum lateness = 6

| Job  | *t**i* | *d**i* |
| ---- | ------ | ------ |
| 1    | 3      | 6      |
| 2    | 2      | 8      |
| 3    | 1      | 9      |
| 4    | 4      | 9      |
| 5    | 3      | 14     |
| 6    | 2      | 15     |

- Possible greedy approaches
  - Sort jobs in nondecreasing order of processing time ti 
  - **Shortest Jobs First** **(?)
  -  Sort jobs in nondecreasing order of slack di - ti :
  - **Smallest Slack-Time First** **(?)**
  - ** â¢ Sort jobs in nondecreasing order of deadline di :
  - **Earliest Deadline First** **(O)**
  - An optimal schedule *S* = {1, 2, 3, 4, 5, 6} â†’ maximum lateness = 1

| Job  | *t**i* | *d**i* |
| ---- | ------ | ------ |
| 1    | 3      | 6      |
| 2    | 2      | 8      |
| 3    | 1      | 9      |
| 4    | 4      | 9      |
| 5    | 3      | 14     |
| 6    | 2      | 15     |

- Correctness of â€œEarliest-deadline-firstâ€-based algorithm

  - ì‚¬ì‹¤

    1. ë§Œì•½ ì£¼ì–´ì§„ scheduleì— inversionì´ ìˆì„ ê²½ìš°, ìµœì†Œí•œ ì—°ë‹¬ì•„ scheduleëœ ë‘ ê°œì˜ inversionëœ jobì´ ìˆìŒ.
       - Inversionì´ë€ deadline ê´€ì ì—ì„œ ë´¤ì„ ë•Œ ì„œë¡œ ìˆœì„œê°€ ë’¤ ë°”ë€ ë‘ ê°œì˜ jobì˜ ìŒ ì„ ë§í•¨.

    2. ì—°ë‹¬ì•„ ìˆëŠ” inversion ìƒíƒœì˜ ë‘ ê°œì˜ jobì˜ ìˆœì„œë¥¼ ì„œë¡œ ë°”ê¿€ ê²½ìš°, maximum latenessë¥¼ ì¦ê°€ì‹œí‚¤ì§€ ì•ŠìŒ.

  - ì¦ëª…

    1. *S*ë¥¼ ìµœì†Œ ê°œìˆ˜ì˜ inversionì„ ê°€ì§€ëŠ” ìµœì ì˜ scheduleì´ë¼ ê°€ì •. 
    2. ë§Œì•½ *S*ì— inversionì´ ì—†ë‹¤ë©´, ìœ„ì˜ ë°©ë²•ìœ¼ë¡œ êµ¬í•œ scheduleê³¼ ë™ì¼.
    3. ë§Œì•½ *S*ì— inversionì´ ìˆë‹¤ë©´, ì´ ê²½ìš° ì—°ë‹¬ì•„ ìˆëŠ” inversionëœ ë‘ jobì˜ ìˆœì„œë¥¼ ì„œë¡œ ë°”ê¾¸ë©´, ê²°ê³¼ë¡œ ë°œìƒí•˜ëŠ” schedule *Sâ€™*ëŠ” maximum latenessë¥¼ ì¦ê°€ì‹œí‚¤ì§€ ì•ŠìŒìœ¼ë¡œ ì—­ì‹œ ë˜ ë‹¤ë¥¸ ìµœì ì˜ scheduleì„.
    4. ê·¸ëŸ¬ë‚˜ *Sâ€™*ëŠ” *S* ë³´ë‹¤ inversionì˜ ê°œìˆ˜ê°€ ì ìŒ. ì´ëŠ” *S*ì— ëŒ€í•œ ê°€ì •ì— ëŒ€í•œ ëª¨ìˆœ. ë”°ë¼ ì„œ *S*ì—ëŠ” inversionì´ ì—†ê³  ë”°ë¼ì„œ ì´ëŠ” ìœ„ì˜ ë°©ë²•ìœ¼ë¡œ êµ¬í•œ scheduleê³¼ ë™ì¼í•¨.

